function t(t,o,e){return t>=o&&t<=e||t>=e&&t<=o}function o(t,o,e){return`${e.zoom},0,0,0,0,${e.zoom},0,0,0,0,1,0,${-t*e.zoom+e.cameraWidth/2},${-o*e.zoom+e.cameraHeight/2},0,1`}var e,s,n;!function(t){t.none="none",t.left="left",t.middle="middle",t.right="right",t.invalid="invalid"}(e||(e={})),function(t){t.node="node",t.connector="connector",t.line="line",t.unspecified="unspecified",t.invalid="invalid"}(s||(s={})),function(t){t.idle="idle",t.dragging="dragging",t.panning="panning",t.connecting="connecting",t.selecting="selecting",t.invalid="invalid"}(n||(n={}));class i{g;gid;position_x;position_y;type;constructor(t){this.g=t,t.gid++,this.gid=t.gid.toString(),this.position_x=0,this.position_y=0,this.type=s.unspecified}bindFunction(t){t.onmousedown=this.domMouseDown.bind(this),t.ontouchstart=this.domTouchStart.bind(this)}domMouseDown(t){this.domCursorDown(t.button,t.clientX,t.clientY),t.stopPropagation()}domTouchStart(t){this.domCursorDown(0,t.touches[0].clientX,t.touches[0].clientY),t.stopPropagation()}domCursorDown(t,o,s){console.debug(`Base class mousedown event triggered on ${this.gid}!`),0==t?this.g.currentMouseDown=e.left:1==t?this.g.currentMouseDown=e.middle:2==t&&(this.g.currentMouseDown=e.right),this.g.targetObject=this,this.g.mousedown_x=o,this.g.mousedown_y=s,this.g.dx=0,this.g.dy=0,this.g.dx_offset=0,this.g.dy_offset=0,this.customCursorDown({button:t,clientX:o,clientY:s})}customCursorDown(t){}domCursorUp(){}onFocus(){}offFocus(){}onDrag(){}onPan(){}destroy(){}}class r extends i{parent;config;dom;constructor(t,o,e){super(e),this.config=t,this.parent=o,this.dom=null}}class c extends r{name;dom;prop;constructor(t,o,e,s){super(o,e,s),this.name=o.name,this.prop=e.prop,this.dom=t}bindFunction(t){}addInputUpdateListener(t,o){this.dom.addEventListener(t,o.bind(this))}}class a extends r{name;connector_x;connector_y;c_total_offset_x;c_total_offset_y;prop;constructor(t,o,e,s){super(o,e,s),this.connector_x=0,this.connector_y=0,this.c_total_offset_x=0,this.c_total_offset_y=0,this.dom=t,this.parent=e,this.prop=e.prop,o.name?this.name=o.name:(s.gid++,this.name=s.gid.toString()),this.g.globalNodes[this.gid]=this,this.bindFunction(this.dom),this.dom.setAttribute("sl-gid",this.gid.toString())}pxToInt(t){return parseInt(t.substring(0,t.length-2))}getComputed(t,o){const e=window.getComputedStyle(t,null).getPropertyValue(o);return e.endsWith("px")?this.pxToInt(e):parseInt(e)}updateDOMproperties(){let t=this.dom.getBoundingClientRect(),o=this.parent.dom.getBoundingClientRect();this.c_total_offset_x=(t.left-o.left)/this.g.zoom+t.width/2/this.g.zoom,this.c_total_offset_y=(t.top-o.top)/this.g.zoom+t.height/2/this.g.zoom}setLineXY(t,o,e){t.setAttribute("x1","0"),t.setAttribute("y1","0"),t.setAttribute("x2",""+o),t.setAttribute("y2",""+e),t.setAttribute("stroke-width","4")}}class u extends a{peerOutput;updateFunction=()=>{console.debug("Update function not set for input connector")};constructor(t,o,e,s){super(t,o,e,s),this.peerOutput=null}domTouchStart(t){this.domCursorDown(0,t.touches[0].clientX,t.touches[0].clientY),t.stopPropagation()}domMouseDown(t){this.domCursorDown(t.button,t.clientX,t.clientY),t.stopPropagation()}domCursorDown(t,o,e){this.peerOutput&&(super.domCursorDown(t,o,e),this.g.targetObject=this.peerOutput,this.g.dx_offset=(this.connector_x-this.peerOutput.connector_x)*this.g.zoom,this.g.dy_offset=(this.connector_y-this.peerOutput.connector_y)*this.g.zoom,this.g.dx=this.g.dx_offset,this.g.dy=this.g.dy_offset,this.peerOutput.customCursorDown({button:t,clientX:o,clientY:e}),this.peerOutput.disconnectFromInput(this))}updateConnectorPosition(){this.connector_x=this.parent.position_x+this.c_total_offset_x,this.connector_y=this.parent.position_y+this.c_total_offset_y}disconnectFromOutput(){this.peerOutput=null}connectToOutput(t){this.peerOutput=t}nodeDrag(){this.updateConnectorPosition(),this.peerOutput&&this.peerOutput.nodeDrag()}destroy(){this.peerOutput&&this.peerOutput.disconnectFromInput(this)}}class h extends a{val;svgTmp;svgLines;peerInputs=[];constructor(t,o,e,s){super(t,o,e,s),this.val=null,this.svgTmp={svg:null,line:null},this.svgLines=[],this.dom=t}connectToInput(t){if(console.debug("Connecting to input: ",t),this===t.peerOutput)return void console.debug("Already connected");t.peerOutput&&(console.debug("Disconnecting from: ",t.peerOutput),t.peerOutput.disconnectFromInput(t),t.disconnectFromOutput()),console.debug("Now connecting to: ",t),t.connectToOutput(this),this.peerInputs.push(t);const o=this.createNewSVG(),e=o[0],s=o[1],n={svg:e,line:s,to:t,from:this,connector_x:this.connector_x,connector_y:this.connector_y,x2:0,y2:0,connector:this};this.svgLines.push(n),this.g.globalLines.push(n),this.g.canvas.appendChild(e),this.setLineXY(s,t.connector_x-this.connector_x,t.connector_y-this.connector_y)}disconnectFromInput(t){console.debug("Disconnecting from input: ",t);for(const o of this.svgLines)if(o.to==t){this.g.canvas.removeChild(o.svg),this.svgLines=this.svgLines.filter((t=>t!=o)),this.g.globalLines=this.g.globalLines.filter((t=>t!=o)),console.debug("Deleted line: ",o);break}t.disconnectFromOutput(),this.peerInputs=this.peerInputs.filter((o=>o.gid!=t.gid))}updateConnectorPosition(){this.connector_x=this.parent.position_x+this.c_total_offset_x,this.connector_y=this.parent.position_y+this.c_total_offset_y}moveToParent(){if(this.updateConnectorPosition(),this.svgTmp.line&&(this.svgTmp.svg.style.transform=`translate3d(${this.connector_x}px, ${this.connector_y}px, 0)`),!(this.svgLines.length<1))for(const t of this.svgLines)t.svg.style.transform=`translate3d(${this.connector_x}px, ${this.connector_y}px, 0)`,t.connector_x=this.connector_x,t.connector_y=this.connector_y,t.x2=t.to.connector_x-this.connector_x,t.y2=t.to.connector_y-this.connector_y,this.setLineXY(t.line,t.x2,t.y2)}createNewSVG(t=!1){console.debug("Creating new SVG");const o=document.createElementNS("http://www.w3.org/2000/svg","svg");o.classList.add("sl-connector-svg"),o.setAttribute("output-gid",this.gid.toString()),t&&o.classList.add("tmp"),o.style.pointerEvents="none",o.style.position="absolute",o.style.overflow="visible",o.setAttribute("width","4"),o.setAttribute("height","4"),o.style.willChange="transform";const e=document.createElementNS("http://www.w3.org/2000/svg","line");return e.classList.add("sl-connector-line"),e.classList.add("tmp"),e.setAttribute("stroke-width","4"),o.appendChild(e),this.updateConnectorPosition(),console.debug("connector x: "+this.connector_x),o.style.transform=`translate3d(${this.connector_x}px, ${this.connector_y}px, 0)`,this.g.canvas.appendChild(o),[o,e]}customCursorDown(t){console.debug(`ConnectorComponent mousedown event triggered on ${this.gid}!`);const o=this.createNewSVG(!0);this.svgTmp.svg=o[0],this.svgTmp.line=o[1],this.moveToParent(),this.setLineXY(this.svgTmp.line,this.g.dx,this.g.dy)}onDrag(){let t=9999,o=0,e=0;const s=this.g.hoverDOM;if(s&&s.classList.contains("sl-input-connector")){const n=s.getAttribute("sl-gid");if(!n)return;console.debug("Hovering over input connector: ",n);const i=this.g.globalNodes[n];i.updateConnectorPosition(),o=i.connector_x,e=i.connector_y,t=Math.sqrt(Math.pow(this.connector_x+this.g.dx/this.g.zoom-o,2)+Math.pow(this.connector_y+this.g.dy/this.g.zoom-e,2))}t<40?this.setLineXY(this.svgTmp.line,o-this.connector_x,e-this.connector_y):this.setLineXY(this.svgTmp.line,this.g.dx/this.g.zoom,this.g.dy/this.g.zoom)}nodeDrag(){this.moveToParent()}deleteTmpSvg(){this.svgTmp.svg&&this.g.canvas.removeChild(this.svgTmp.svg),this.svgTmp={svg:null,line:null}}domCursorUp(){console.debug("connector domMouseUp");const t=this.g.hoverDOM;if(t&&t.classList.contains("sl-input-connector")){const o=t.getAttribute("sl-gid");if(console.debug("Hovering over input connector: ",o),!o)return void this.deleteTmpSvg();const e=this.g.globalNodes[o];this.connectToInput(e),e.prop[e.name]=this.prop[this.name],e.updateFunction()}this.deleteTmpSvg(),console.debug("Canvas children: ",this.g.canvas.children)}getValue(){return this.parent.exec(),this.val}destroy(){for(const t of this.peerInputs)this.disconnectFromInput(t);for(const t of this.svgLines)console.debug("Removing svg: ",t),this.g.canvas.removeChild(t.svg)}}class d extends i{inputConnectors;outputConnectors;outputCount;components;dom;nodeWidth=0;nodeHeight=0;panStartX;panStartY;overlapping;freeze;type;prop;outputProp;constructor(t,o){super(o),this.inputConnectors={},this.outputConnectors={},this.outputCount=0,this.components={},this.panStartX=this.position_x,this.panStartY=this.position_y,this.overlapping=null,this.freeze=!1,this.type=s.node,this.dom=t,this.dom.style.willChange="transform",this.dom.style.position="absolute",this.dom.style.transformOrigin="top left",this.dom.id=this.gid,this.bindFunction(this.dom),this.g.nodeArray.push(this),new ResizeObserver((()=>{this.updateDOMproperties()})).observe(this.dom),this.prop={},this.outputProp={},this.prop=new Proxy(this.prop,{set:(t,o,e)=>(t[o=o.toString()]=e,o in this.outputProp&&this.evaluate(o),!0),get:(t,o)=>t[o=o.toString()]})}addNodeToCanvas(t,o){this.position_x=t,this.position_y=o,this.nodeWidth=this.dom.offsetWidth,this.nodeHeight=this.dom.offsetHeight,this.dom.style.transform=`translate3d(${this.position_x}px, ${this.position_y}px, 0)`,this.updateDOMproperties(),this.g.canvas.appendChild(this.dom)}addOutputConnector(t,o){const e=new h(t,{name:o},this,this.g);return this.outputConnectors[o]=e,this.prop[o]=null,this.outputProp[o]=null,e}addInputConnector(t,o){const e=new u(t,{name:o},this,this.g);return this.inputConnectors[o]=e,this.prop[o]=null,e}addInputForm(t,o){const e=new c(t,{name:o},this,this.g);return this.prop[o]=null,e}findInput(t){for(const o of Object.values(this.inputConnectors))if(o.name==t)return o;return null}findOutput(t){for(const o of Object.values(this.outputConnectors))if(o.name==t)return o;return null}setStartPositions(){this.panStartX=this.position_x,this.panStartY=this.position_y}customCursorDown(t){console.debug(`Node class mousedown event triggered on ${this.gid}!`);let o=!1;for(let t=0;t<this.g.focusNodes.length;t++)if(this.g.focusNodes[t].gid==this.gid){o=!0;break}if(o)for(let t=0;t<this.g.focusNodes.length;t++)this.g.focusNodes[t].setStartPositions();else{for(let t=0;t<this.g.focusNodes.length;t++)this.g.focusNodes[t].offFocus();this.g.focusNodes=[this],this.onFocus()}this.setStartPositions()}domCursorUp(){if(this.freeze)return;if(this.position_x=this.panStartX+this.g.dx/this.g.zoom,this.position_y=this.panStartY+this.g.dy/this.g.zoom,console.debug("Mouse has moved: "+this.g.mouseHasMoved),!this.g.mouseHasMoved&&this.g.targetObject&&this.g.targetObject.gid==this.gid){console.debug("Mouse has not moved");for(let t=0;t<this.g.focusNodes.length;t++)this.g.focusNodes[t].offFocus();return this.g.focusNodes=[this],void this.onFocus()}if(null==this.overlapping)return;const t=this.overlapping.from,o=this.overlapping.to,e=Object.values(this.inputConnectors)[0],s=Object.values(this.outputConnectors)[0];t.disconnectFromInput(o),t.connectToInput(e),s.connectToInput(o)}onDrag(){if(this.freeze)return;this.position_x=this.panStartX+this.g.dx/this.g.zoom,this.position_y=this.panStartY+this.g.dy/this.g.zoom,this.dom.style.transform=`translate3d(${this.position_x}px, ${this.position_y}px, 0)`;for(const t of Object.values(this.inputConnectors))t.nodeDrag();for(const t of Object.values(this.outputConnectors))t.nodeDrag();if(this.overlapping=null,0==Object.keys(this.inputConnectors).length&&0==Object.keys(this.outputConnectors).length)return;let o=9999;for(const e of this.g.globalLines)e.line.classList.remove("overlapping"),t(this.position_x+this.nodeWidth/2,e.connector_x,e.connector_x+e.x2)&&t(this.position_y+this.nodeHeight/2,e.connector_y,e.connector_y+e.y2)&&(e.y2+e.connector_x)/2<o&&(this.overlapping=e,o=(e.y2+this.position_y)/2);this.overlapping&&this.overlapping.line.classList.add("overlapping")}onFocus(){this.dom.classList.add("focused"),this.dom.style.zIndex="20",this.updateDOMproperties()}offFocus(){this.dom.classList.remove("focused"),this.dom.style.zIndex="10"}updateDOMproperties(){this.nodeHeight=this.dom.offsetHeight,this.nodeWidth=this.dom.offsetWidth;for(const t of Object.values(this.inputConnectors))t.updateDOMproperties();for(const t of Object.values(this.outputConnectors))t.updateDOMproperties()}evaluate(t){console.debug("Update all nodes connected to "+t);const o=this.outputConnectors[t];if(o)for(const e of o.peerInputs)console.debug(`Update input ${e.name} connected to ${t} with value ${this.prop[t]}`),e.prop[e.name]=this.prop[t],e.updateFunction()}exec(){}destroy(){this.g.canvas?.removeChild(this.dom);for(const t of Object.values(this.inputConnectors))t.destroy();for(const t of Object.values(this.outputConnectors))t.destroy()}}class l{g;constructor(t){this.g={canvas:null,canvasContainer:null,canvasBackground:null,currentMouseDown:e.none,mousedown_x:0,mousedown_y:0,mouse_x:0,mouse_y:0,mouse_x_world:0,mouse_y_world:0,camera_pan_start_x:0,camera_pan_start_y:0,dx:0,dy:0,dx_offset:0,dy_offset:0,overrideDrag:!1,camera_x:0,camera_y:0,zoom:1,cameraWidth:0,cameraHeight:0,targetObject:null,focusNodes:[],hoverDOM:null,gid:0,nodeArray:[],globalLines:[],globalNodes:{},selectionBox:null,mouseHasMoved:!1,ignoreMouseUp:!1,prevTouches:null,prevSingleTouchTime:0};const o=this.g;if(o.canvasContainer=document.getElementById(t),!o.canvasContainer)return void console.error("Canvas not found");o.cameraWidth=o.canvasContainer.clientWidth,o.cameraHeight=o.canvasContainer.clientHeight,console.debug(`Canvas size: ${o.cameraWidth}x${o.cameraHeight}`);const s=document.createElement("div");s.style.position="relative",s.style.top="0px",s.style.left="0px",s.className="canvas",o.canvasContainer.appendChild(s),o.canvas=s,o.canvas.style.transform=`translate(${o.cameraWidth/2}px, ${o.cameraHeight/2}px)`,o.canvas.style.width="0px",o.canvas.style.height="0px",o.canvasContainer.style.overflow="hidden",o.canvasContainer.tabIndex=0,o.canvasContainer.style.position="relative";const n=document.createElement("div");n.id="sl-background",n.style.width=10*o.cameraWidth+"px",n.style.height=10*o.cameraHeight+"px",n.style.transform=`translate(${5*-o.cameraWidth}px, ${5*-o.cameraHeight}px)`,n.style.transformOrigin="center",n.style.zIndex="0",n.style.position="absolute",o.canvas.appendChild(n),o.canvasBackground=n;const i=document.createElement("div");i.id="sl-selection-box",i.style.position="absolute",i.style.pointerEvents="none",o.canvasContainer.appendChild(i),o.selectionBox=i,o.canvasContainer.addEventListener("mousedown",this.onMouseDown.bind(this)),o.canvasContainer.addEventListener("mousemove",this.onMouseMove.bind(this)),o.canvasContainer.addEventListener("mouseup",this.onMouseUp.bind(this)),o.canvasContainer.addEventListener("wheel",this.onWheel.bind(this)),o.canvasContainer.addEventListener("keydown",this.onKeyDown.bind(this)),document.addEventListener("mousemove",this.onMouseMove.bind(this)),document.addEventListener("mouseup",this.onMouseUp.bind(this)),o.canvasContainer.addEventListener("touchstart",this.onTouchStart.bind(this)),o.canvasContainer.addEventListener("touchmove",this.onTouchMove.bind(this)),o.canvasContainer.addEventListener("touchend",this.onTouchEnd.bind(this)),window.requestAnimationFrame(this.step.bind(this))}onTouchStart(t){if(t.touches.length>1){1==this.g.prevTouches.length&&this.onCursorUp(),console.debug("Multitouch touchstart"),this.g.currentMouseDown=e.middle;let o=(t.touches[0].clientX+t.touches[1].clientX)/2,s=(t.touches[0].clientY+t.touches[1].clientY)/2;return this.onCursorDown(1,o,s),void(this.g.prevTouches=t.touches)}this.onCursorDown(0,t.touches[0].clientX,t.touches[0].clientY)}onMouseDown(t){this.onCursorDown(t.button,t.clientX,t.clientY)}onCursorDown(t,o,s){console.debug("Cursor down: "+t);const n=document.querySelector(".sl-connector-svg.tmp");if(n){console.debug("Cursor down with tmp line");const t=n.getAttribute("output-gid");if(null!=t){console.debug("Cursor down with tmp line and output gid: "+t);const o=this.g.globalNodes[t];o&&(o.domCursorUp(),this.onCursorUp())}}const i=this.g;if(!i.overrideDrag){i.currentMouseDown!=e.none&&(i.selectionBox.style.width="0px",i.selectionBox.style.height="0px",i.selectionBox.style.left="0px",i.selectionBox.style.top="0px"),i.currentMouseDown=1==t?e.middle:0==t?e.left:e.invalid,i.focusNodes=[];for(const t of i.nodeArray)t.offFocus();i.mousedown_x=o,i.mousedown_y=s,i.camera_pan_start_x=i.camera_x,i.camera_pan_start_y=i.camera_y}}onMouseMove(t){this.onCursorMove(t.target,t.clientX,t.clientY)}onTouchMove(t){if(t.touches.length>1){if(null==this.g.prevTouches||2!=this.g.prevTouches.length)return void(2==t.touches.length&&(this.g.prevTouches=t.touches));let o=t.touches[0],e=t.touches[1],s=null,n=null;for(let i=0;i<t.touches.length;i++)o.identifier==this.g.prevTouches[i].identifier?s=this.g.prevTouches[i]:e.identifier==this.g.prevTouches[i].identifier&&(n=this.g.prevTouches[i]);let i=-2*(Math.sqrt(Math.pow(o.clientX-e.clientX,2)+Math.pow(o.clientY-e.clientY,2))-Math.sqrt(Math.pow(s.clientX-n.clientX,2)+Math.pow(s.clientY-n.clientY,2))),r=(o.clientX+e.clientX)/2,c=(o.clientY+e.clientY)/2,a=r-this.g.canvasContainer.offsetLeft,u=c-this.g.canvasContainer.offsetTop;return this.onCursorMove(document.elementFromPoint(a,u),a,u),this.g.mouse_x=a,this.g.mouse_y=u,this.onZoom(i),void(this.g.prevTouches=t.touches)}let o=document.elementFromPoint(t.touches[0].clientX,t.touches[0].clientY);this.onCursorMove(o,t.touches[0].clientX,t.touches[0].clientY),this.g.prevTouches=t.touches}onCursorMove(t,s,n){console.debug("Cursor move");const i=this.g;i.hoverDOM=t,i.mouse_x=s-i.canvasContainer.offsetLeft,i.mouse_y=n-i.canvasContainer.offsetTop;let r=(i.mouse_x-i.cameraWidth/2)/i.zoom+i.camera_x,c=(i.mouse_y-i.cameraHeight/2)/i.zoom+i.camera_y;if(i.mouse_x_world=r,i.mouse_y_world=c,i.dx=s-i.mousedown_x+i.dx_offset,i.dy=n-i.mousedown_y+i.dy_offset,i.currentMouseDown!=e.none&&!i.overrideDrag&&(0===i.dx&&0===i.dy||(i.mouseHasMoved=!0),null==i.targetObject))if(i.currentMouseDown==e.middle)i.camera_x=i.camera_pan_start_x-i.dx/i.zoom,i.camera_y=i.camera_pan_start_y-i.dy/i.zoom,i.canvas.style.transform=`matrix3d(${o(i.camera_x,i.camera_y,i)})`,i.canvasBackground.style.transform=`translate(${i.camera_x+5*-i.cameraWidth}px, ${i.camera_y+5*-i.cameraHeight}px)`,i.canvasBackground.style.backgroundPosition=`${-i.camera_x}px ${-i.camera_y}px`,i.canvas.style.cursor="grabbing";else if(i.currentMouseDown==e.left){i.selectionBox.style.width=Math.abs(i.dx)+"px",i.selectionBox.style.height=Math.abs(i.dy)+"px",i.selectionBox.style.left=Math.min(i.mousedown_x,i.mouse_x)+"px",i.selectionBox.style.top=Math.min(i.mousedown_y,i.mouse_y)+"px";let t=(Math.min(i.mousedown_x,i.mouse_x)-i.cameraWidth/2)/i.zoom+i.camera_x,o=(Math.min(i.mousedown_y,i.mouse_y)-i.cameraHeight/2)/i.zoom+i.camera_y,e=(Math.max(r,i.mousedown_x,i.mouse_x)-i.cameraWidth/2)/i.zoom+i.camera_x,s=(Math.max(c,i.mousedown_y,i.mouse_y)-i.cameraHeight/2)/i.zoom+i.camera_y,n=[];for(const r of i.nodeArray)r.position_x+r.nodeWidth>t&&r.position_x<e&&r.position_y+r.nodeHeight>o&&r.position_y<s?(r.onFocus(),n.push(r)):r.offFocus();i.focusNodes=n}}onMouseUp(t){this.onCursorUp()}onTouchEnd(t){this.onCursorUp()}onCursorUp(){const t=this.g;if(console.debug("Cursor up"),t.ignoreMouseUp)t.ignoreMouseUp=!1;else{if(t.currentMouseDown==e.left)if(null==t.targetObject)t.selectionBox.style.width="0px",t.selectionBox.style.height="0px",t.selectionBox.style.left="0px",t.selectionBox.style.top="0px";else if(t.targetObject.type==s.node)for(const o of t.focusNodes)console.debug("Mouse up with target node: "+o.gid),o.domCursorUp();else t.targetObject.domCursorUp();t.currentMouseDown=e.none,t.overrideDrag&&(t.canvasBackground.style.cursor="default"),t.overrideDrag=!1,t.canvas.style.cursor="default",t.targetObject=null,t.dx=0,t.dy=0,t.dx_offset=0,t.dy_offset=0,t.mouseHasMoved=!1}}onWheel(t){this.onZoom(t.deltaY),t.preventDefault()}onZoom(t=0){const e=this.g;let s=1*e.zoom*(-t/1e3);e.zoom+s<.2?s=.2-e.zoom:e.zoom+s>1&&(s=1-e.zoom);let n=e.zoom/(e.zoom+s),i=e.cameraWidth/e.zoom*(n-1)*(1-(1.5*e.cameraWidth-e.mouse_x)/e.cameraWidth),r=e.cameraHeight/e.zoom*(n-1)*(1-(1.5*e.cameraHeight-e.mouse_y)/e.cameraHeight);e.zoom+=s,e.camera_x-=i,e.camera_y-=r,e.canvas.style.transform=`matrix3d(${o(e.camera_x,e.camera_y,e)})`}onKeyDown(t){switch(console.debug("Keydown: "+t.key),t.key){case"Backspace":case"Delete":if(this.g.focusNodes.length>0)for(const t of this.g.focusNodes)console.debug("Deleting node: "+t.gid),this.deleteNode(t.gid)}}step(){if(this.g.targetObject?.type==s.node)for(const t of this.g.focusNodes)t.onDrag();else this.g.targetObject?.onDrag();window.requestAnimationFrame(this.step.bind(this))}createNode(t){const o=new d(t,this.g);return this.g.globalNodes[o.gid]=o,o}createNodeAuto(t){const o=new d(t,this.g);this.g.globalNodes[o.gid]=o;const e=t.querySelectorAll(".sl-input");for(let t=0;t<e.length;t++){const s=e[t],n=s.getAttribute("sl-name"),i=o.addInputForm(s,n);for(let t=0;t<s.attributes.length;t++){const o=s.attributes[t];if(o.name.startsWith("sl-event:")){const t=o.name.split(":")[1],e=window[o.value];console.debug("Adding event listener: "+t),i.addInputUpdateListener(t,e)}}}const s=t.querySelectorAll(".sl-input-connector");for(let t=0;t<s.length;t++){const e=s[t],n=e.getAttribute("sl-name"),i=o.addInputConnector(e,n),r=e.getAttribute("sl-update");if(console.debug("Update function: "+r),null!=r||null!=r){console.debug("Update function: "+r,i);const t=window[r];i.updateFunction=t.bind(i)}}const n=t.querySelectorAll(".sl-output-connector");for(let t=0;t<n.length;t++){const e=n[t],s=e.getAttribute("sl-name");o.addOutputConnector(e,s)}for(let e=0;e<t.attributes.length;e++){const s=t.attributes[e];if(s.name.startsWith("sl-init")){const t=window[s.value];console.debug("Calling init func: "+t),t.bind(o)()}}return o}addNode(t,o,e){t.addNodeToCanvas(o,e)}addNodeAtMouse(t,o){this.g.ignoreMouseUp=!0;let s=this.g.mouse_x_world,n=this.g.mouse_y_world;console.debug("Adding node at "+s+", "+n),this.addNode(t,s,n),t.setStartPositions(),this.g.currentMouseDown=e.left,this.g.mousedown_x=this.g.mouse_x,this.g.mousedown_y=this.g.mouse_y,this.g.camera_pan_start_x=this.g.camera_x,this.g.camera_pan_start_y=this.g.camera_y,this.g.focusNodes=[t],this.g.targetObject=t;for(const t of this.g.nodeArray)t.offFocus();this.onMouseMove(o)}deleteNode(t){return t in this.g.globalNodes?(this.g.globalNodes[t].destroy(),delete this.g.globalNodes[t],t):(console.error("Node not found: "+t),null)}focusNode(t){if(!(t in this.g.globalNodes))return null;return this.g.globalNodes[t].onFocus(),t}connectNodes(t,o,e,s){const n=this.g.globalNodes[t],i=this.g.globalNodes[e];if(!(n&&i&&n instanceof d&&i instanceof d))return null;const r=n.findOutput(o),c=i.findInput(s);return r&&c?(r.connectToInput(c),0):null}}export{l as default};
